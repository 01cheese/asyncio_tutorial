## **Глава 4: Синтаксис `async` и `await`**

### **4.1. Введение в `async` и `await`**

Ключевые слова `async` и `await` являются основными строительными блоками асинхронного программирования в Python. Они позволяют разработчикам писать код, который выполняется асинхронно, делая его более читаемым и управляемым по сравнению с традиционными подходами на основе колбэков.

#### **4.1.1. История появления `async` и `await`**

До введения `async` и `await` в Python 3.5, асинхронное программирование реализовывалось с помощью генераторов и специальных библиотек, таких как `asyncio`, `Twisted` и `gevent`. Этот подход был мощным, но сложным для понимания и использования. Введение `async` и `await` значительно упростило написание асинхронного кода, сделав его более похожим на синхронный стиль программирования.

### **4.2. Ключевое слово `async`**

`async` используется для объявления асинхронных функций, также известных как корутины. Асинхронная функция — это функция, которая может приостанавливать своё выполнение и возобновлять его позже, что позволяет выполнять другие задачи в промежутках.

#### **4.2.1. Синтаксис объявления асинхронной функции**

Асинхронная функция объявляется с использованием ключевого слова `async` перед `def`.

```python
async def my_async_function():
    pass
```

#### **4.2.2. Пример простой асинхронной функции**

```python
import asyncio

async def greet(name):
    print(f"Привет, {name}!")
    await asyncio.sleep(1)
    print(f"До свидания, {name}!")

# Запуск корутины
asyncio.run(greet("Алиса"))
```

**Вывод:**
```
Привет, Алиса!
До свидания, Алиса!
```

В этом примере функция `greet` является асинхронной. Она печатает приветствие, ожидает 1 секунду, а затем печатает прощание. Ключевое слово `await` позволяет приостановить выполнение корутины, не блокируя основной поток.

### **4.3. Ключевое слово `await`**

`await` используется для приостановки выполнения корутины до тех пор, пока другая асинхронная операция не завершится. Это позволяет эффективно управлять асинхронными задачами и избегать блокировок.

#### **4.3.1. Синтаксис использования `await`**

```python
result = await some_async_function()
```

#### **4.3.2. Пример использования `await`**

```python
import asyncio

async def fetch_data():
    print("Начало загрузки данных...")
    await asyncio.sleep(2)  # Симуляция асинхронной операции
    print("Данные загружены.")
    return {"data": "Пример данных"}

async def process_data(data):
    print("Начало обработки данных...")
    await asyncio.sleep(1)  # Симуляция асинхронной обработки
    print("Данные обработаны.")
    return f"Результат: {data['data']}"

async def main():
    data = await fetch_data()
    result = await process_data(data)
    print(result)

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Начало загрузки данных...
Данные загружены.
Начало обработки данных...
Данные обработаны.
Результат: Пример данных
```

В этом примере `await` используется для ожидания завершения функций `fetch_data` и `process_data` без блокировки основного потока выполнения.

### **4.4. Взаимодействие `async` и `await`**

`async` и `await` работают вместе, чтобы создавать асинхронные корутины, которые могут приостанавливать и возобновлять своё выполнение. Это позволяет писать асинхронный код, который выглядит и читается как синхронный, но при этом выполняется асинхронно.

#### **4.4.1. Асинхронная цепочка вызовов**

```python
import asyncio

async def task1():
    print("Задача 1: Начало")
    await asyncio.sleep(1)
    print("Задача 1: Завершение")
    return "Результат задачи 1"

async def task2():
    print("Задача 2: Начало")
    await asyncio.sleep(2)
    print("Задача 2: Завершение")
    return "Результат задачи 2"

async def main():
    result1 = await task1()
    result2 = await task2()
    print(result1)
    print(result2)

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Задача 1: Начало
Задача 1: Завершение
Задача 2: Начало
Задача 2: Завершение
Результат задачи 1
Результат задачи 2
```

В этом примере задачи выполняются последовательно, хотя они и асинхронны. Для параллельного выполнения необходимо использовать дополнительные инструменты, такие как `asyncio.gather`.

### **4.5. Создание и запуск корутин**

Корутины можно запускать различными способами в зависимости от контекста и требований приложения.

#### **4.5.1. Использование `asyncio.run`**

`asyncio.run` — это удобная функция, доступная с Python 3.7, которая создает цикл событий, выполняет корутину и закрывает цикл после завершения.

```python
import asyncio

async def say_hello():
    print("Привет!")
    await asyncio.sleep(1)
    print("Мир!")

asyncio.run(say_hello())
```

**Вывод:**
```
Привет!
Мир!
```

#### **4.5.2. Использование цикла событий вручную**

Для более гибкого управления циклом событий можно создавать и управлять циклом вручную.

```python
import asyncio

async def greet(name):
    print(f"Привет, {name}!")
    await asyncio.sleep(1)
    print(f"До свидания, {name}!")

# Создание цикла событий
loop = asyncio.get_event_loop()

# Запуск корутины
loop.run_until_complete(greet("Боб"))

# Закрытие цикла событий
loop.close()
```

**Вывод:**
```
Привет, Боб!
До свидания, Боб!
```

#### **4.5.3. Запуск нескольких корутин одновременно с `asyncio.gather`**

`asyncio.gather` позволяет запускать несколько корутин параллельно и ждать их завершения.

```python
import asyncio

async def task1():
    await asyncio.sleep(1)
    print("Задача 1 завершена")

async def task2():
    await asyncio.sleep(2)
    print("Задача 2 завершена")

async def main():
    await asyncio.gather(task1(), task2())

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Задача 1 завершена
Задача 2 завершена
```

В этом примере обе задачи запускаются одновременно, и общее время выполнения составляет около 2 секунд, вместо 3 секунд при последовательном выполнении.

### **4.6. Практические примеры использования `async` и `await`**

Рассмотрим несколько практических примеров, демонстрирующих использование `async` и `await` в различных контекстах.

#### **4.6.1. Асинхронное чтение файлов с использованием `aiofiles`**

```python
import asyncio
import aiofiles

async def read_file(file_path):
    async with aiofiles.open(file_path, mode='r') as f:
        contents = await f.read()
        print(contents)

async def main():
    await read_file('example.txt')

if __name__ == "__main__":
    asyncio.run(main())
```

**Описание:**
В этом примере используется библиотека `aiofiles` для асинхронного чтения файла. Это позволяет программе продолжать выполнение других задач, пока файл читается.

#### **4.6.2. Асинхронные HTTP-запросы с использованием `aiohttp`**

```python
import asyncio
import aiohttp

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    async with aiohttp.ClientSession() as session:
        html = await fetch(session, 'https://www.example.com')
        print(html)

if __name__ == "__main__":
    asyncio.run(main())
```

**Описание:**
Этот пример демонстрирует выполнение асинхронного HTTP-запроса с использованием библиотеки `aiohttp`. Асинхронные запросы позволяют отправлять и получать данные без блокировки основного потока выполнения.

#### **4.6.3. Асинхронная обработка нескольких задач с `asyncio.gather`**

```python
import asyncio

async def download_file(file_id):
    print(f"Начало загрузки файла {file_id}")
    await asyncio.sleep(2)  # Симуляция загрузки
    print(f"Загрузка файла {file_id} завершена")
    return f"Файл {file_id}"

async def main():
    tasks = [download_file(i) for i in range(1, 4)]
    results = await asyncio.gather(*tasks)
    print("Все файлы загружены:")
    for result in results:
        print(result)

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Начало загрузки файла 1
Начало загрузки файла 2
Начало загрузки файла 3
Загрузка файла 1 завершена
Загрузка файла 2 завершена
Загрузка файла 3 завершена
Все файлы загружены:
Файл 1
Файл 2
Файл 3
```

**Описание:**
В этом примере три задачи загрузки файлов выполняются одновременно с помощью `asyncio.gather`, что позволяет значительно сократить общее время выполнения.

### **4.7. Управление временем выполнения и задержками**

Асинхронное программирование позволяет эффективно управлять временем выполнения задач и использовать задержки без блокировки основного потока.

#### **4.7.1. Использование `asyncio.sleep` для создания задержек**

`asyncio.sleep` — асинхронная версия функции `time.sleep`, которая приостанавливает выполнение корутины на заданное время без блокировки цикла событий.

```python
import asyncio

async def delayed_message(message, delay):
    await asyncio.sleep(delay)
    print(message)

async def main():
    await asyncio.gather(
        delayed_message("Сообщение через 1 секунду", 1),
        delayed_message("Сообщение через 2 секунды", 2),
        delayed_message("Сообщение через 3 секунды", 3),
    )

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Сообщение через 1 секунду
Сообщение через 2 секунды
Сообщение через 3 секунды
```

#### **4.7.2. Ограничение времени выполнения с помощью `asyncio.wait_for`**

`asyncio.wait_for` позволяет ограничить время выполнения корутины, после которого она будет отменена, если не завершится вовремя.

```python
import asyncio

async def long_running_task():
    await asyncio.sleep(5)
    print("Долгосрочная задача завершена")

async def main():
    try:
        await asyncio.wait_for(long_running_task(), timeout=3)
    except asyncio.TimeoutError:
        print("Задача превысила лимит времени и была отменена")

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Задача превысила лимит времени и была отменена
```

**Описание:**
В этом примере `long_running_task` симулирует долгую операцию, которая не завершается в течение установленного тайм-аута, что приводит к её отмене.

### **4.8. Работа с исключениями в асинхронных функциях**

Обработка исключений в асинхронных функциях аналогична синхронному коду, но требует внимания к тому, где именно и как они обрабатываются.

#### **4.8.1. Обработка исключений внутри корутины**

```python
import asyncio

async def faulty_task():
    await asyncio.sleep(1)
    raise ValueError("Произошла ошибка в корутине")

async def main():
    try:
        await faulty_task()
    except ValueError as e:
        print(f"Исключение поймано: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Исключение поймано: Произошла ошибка в корутине
```

#### **4.8.2. Обработка исключений при использовании `asyncio.gather`**

При использовании `asyncio.gather` исключения в корутинах могут быть собраны вместе. По умолчанию, если одна из корутин завершится с ошибкой, `asyncio.gather` выбросит исключение.

```python
import asyncio

async def task_success():
    await asyncio.sleep(1)
    print("Задача успешно завершена")

async def task_failure():
    await asyncio.sleep(2)
    raise RuntimeError("Ошибка в задаче")

async def main():
    try:
        await asyncio.gather(task_success(), task_failure())
    except RuntimeError as e:
        print(f"Исключение из gather: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Задача успешно завершена
Исключение из gather: Ошибка в задаче
```

**Описание:**
В этом примере `task_failure` завершает выполнение с ошибкой, которая перехватывается в блоке `try-except` в функции `main`.

#### **4.8.3. Использование `asyncio.shield` для защиты корутин от отмены**

`asyncio.shield` позволяет защитить корутину от отмены, сохраняя её выполнение даже при отмене внешней задачи.

```python
import asyncio

async def critical_task():
    print("Критическая задача началась")
    await asyncio.sleep(3)
    print("Критическая задача завершилась")

async def main():
    task = asyncio.create_task(asyncio.shield(critical_task()))
    await asyncio.sleep(1)
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print("Задача была отменена, но критическая задача продолжает выполнение")

if __name__ == "__main__":
    asyncio.run(main())
```

**Вывод:**
```
Критическая задача началась
Задача была отменена, но критическая задача продолжает выполнение
Критическая задача завершилась
```

**Описание:**
В этом примере использование `asyncio.shield` предотвращает отмену критической задачи, даже если внешняя задача отменяется.

### **4.9. Заключение**

Ключевые слова `async` и `await` являются фундаментальными элементами асинхронного программирования в Python. Они позволяют писать асинхронный код, который легко читается и поддерживается, при этом эффективно используя ресурсы системы. В этой главе мы рассмотрели, как объявлять асинхронные функции, использовать `await` для приостановки выполнения корутин, запускать корутины и управлять временем выполнения задач. Также мы изучили практические примеры использования этих ключевых слов в различных контекстах.

Понимание синтаксиса `async` и `await` является важным шагом к освоению асинхронного программирования. В следующих главах мы подробно рассмотрим работу с модулем `asyncio`, изучим его основные компоненты и научимся создавать более сложные асинхронные приложения.